name: Update map data from SharePoint

on:
  workflow_dispatch: {}
  schedule:
    - cron: "0 7 * * *"
    - cron: "0 8 * * *"

permissions:
  contents: write

jobs:
  update-json:
    runs-on: windows-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Pull SharePoint list and build JSON
        shell: pwsh
        env:
          GRAPH_TENANT_ID: ${{ secrets.GRAPH_TENANT_ID }}
          GRAPH_CLIENT_ID: ${{ secrets.GRAPH_CLIENT_ID }}
          GRAPH_CLIENT_SECRET: ${{ secrets.GRAPH_CLIENT_SECRET }}
          # support either URL or hostname/path
          SP_SITE_URL: ${{ secrets.SP_SITE_URL }}
          SP_SITE_HOSTNAME: ${{ secrets.SP_SITE_HOSTNAME }}
          SP_SITE_PATH: ${{ secrets.SP_SITE_PATH }}
          SP_LIST_NAME: ${{ secrets.SP_LIST_NAME }}
        run: |
          $ErrorActionPreference = 'Stop'

          # ---- Resolve site host + path from either SP_SITE_URL or HOSTNAME/PATH ----
          function Resolve-SiteParts {
            param(
              [string]$Url,
              [string]$Host,
              [string]$Path
            )
            if ($Url) {
              try {
                $u = [Uri]$Url
                $host = $u.Host
                $path = $u.AbsolutePath
                if (-not $path.StartsWith("/")) { $path = "/$path" }
                return @{ Host = $host; Path = $path }
              } catch {
                throw "SP_SITE_URL looks invalid: '$Url'"
              }
            }
            if ($Host -and $Path) {
              $p = $Path
              if (-not $p.StartsWith("/")) { $p = "/$p" }
              return @{ Host = $Host; Path = $p }
            }
            throw "Provide either SP_SITE_URL, or both SP_SITE_HOSTNAME and SP_SITE_PATH as repository secrets."
          }

          $siteParts = Resolve-SiteParts -Url $env:SP_SITE_URL -Host $env:SP_SITE_HOSTNAME -Path $env:SP_SITE_PATH
          $SiteHost = $siteParts.Host
          $SitePath = $siteParts.Path

          if (-not $env:SP_LIST_NAME) { $env:SP_LIST_NAME = "Properties_by_RVP" }

          Write-Host "Using site host: $SiteHost"
          Write-Host "Using site path: $SitePath"
          Write-Host "Using list name: $($env:SP_LIST_NAME)"

          # ---- Get Graph token ----
          $body = @{
            client_id     = $env:GRAPH_CLIENT_ID
            scope         = "https://graph.microsoft.com/.default"
            client_secret = $env:GRAPH_CLIENT_SECRET
            grant_type    = "client_credentials"
          }
          $tok = Invoke-RestMethod -Method Post -Uri "https://login.microsoftonline.com/$($env:GRAPH_TENANT_ID)/oauth2/v2.0/token" -Body $body -ErrorAction Stop
          $H = @{ Authorization = "Bearer $($tok.access_token)" }

          # ---- Resolve site + list ----
          $siteUri = "https://graph.microsoft.com/v1.0/sites/$SiteHost:$SitePath"
          $site = Invoke-RestMethod -Headers $H -Uri $siteUri -ErrorAction Stop
          $siteId = $site.id
          if (-not $siteId) { throw "Could not resolve site ID from $siteUri" }

          $listName = $env:SP_LIST_NAME
          $lists = Invoke-RestMethod -Headers $H -Uri "https://graph.microsoft.com/v1.0/sites/$siteId/lists?`$filter=displayName eq '$listName'&`$select=id,displayName" -ErrorAction Stop
          if(-not $lists.value){ throw "List '$listName' not found at $SiteHost$SitePath" }
          $listId = $lists.value[0].id

          # ---- Pull all items (expand fields) ----
          $items = @()
          $url = "https://graph.microsoft.com/v1.0/sites/$siteId/lists/$listId/items?`$expand=fields&`$top=999"
          while($url){
            $r = Invoke-RestMethod -Headers $H -Uri $url -ErrorAction Stop
            $items += $r.value
            $url = $r.'@odata.nextLink'
          }

          # ---- First run helper: dump detected internal field names ----
          if($items.Count -gt 0){
            ($items[0].fields | Get-Member -MemberType NoteProperty | Select -ExpandProperty Name |
              Sort-Object) | Out-File -Encoding utf8 -FilePath "$PWD/detected_sharepoint_fields.txt"
            Write-Host "Wrote detected_sharepoint_fields.txt"
          } else {
            Write-Warning "No list items returned."
          }

          # ---- Map SharePoint fields -> JSON consumed by the site ----
          function Map-Row($f){
            [pscustomobject]@{
              name           = $f.Title
              type           = $f.TYPE
              units          = $f.field_2
              manager        = $f.field_3
              assistant_mgr  = $f.field_4
              compliance     = $f.field_5
              address        = $f.field_6
              city           = $f.field_7
              state          = $f.field_8
              zip            = $f.field_9
              office_phone   = $f.field_10
              fax            = $f.field_11
              manager_email  = $f.field_12
              rpm            = $f.field_13
              rvp            = $f.field_14
              lat            = [double]($f.Latitude   ?? 0)
              lng            = [double]($f.Longitude  ?? 0)
              owner          = $f.OWNER   # <-- your new column
            }
          }

          $out = @()
          foreach($it in $items){
            $out += Map-Row $it.fields
          }

          # ---- Backup, then write JSON ----
          $jsonFile = "final_properties_with_coords_and_rvp.json"
          if (Test-Path $jsonFile) {
            $stamp = Get-Date -Format "yyyyMMdd-HHmmss"
            Copy-Item $jsonFile "backup_final_properties_$stamp.json"
          }
          $out | ConvertTo-Json -Depth 4 | Set-Content -Encoding utf8 -Path $jsonFile
          Write-Host "Wrote $jsonFile with $($out.Count) rows."

      - name: Commit JSON and helper file
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "Auto-update: final_properties_with_coords_and_rvp.json from SharePoint"
          file_pattern: |
            final_properties_with_coords_and_rvp.json
            backup_final_properties_*.json
            detected_sharepoint_fields.txt
          commit_user_name: ${{ secrets.COMMIT_USER_NAME }}
          commit_user_email: ${{ secrets.COMMIT_USER_EMAIL }}
